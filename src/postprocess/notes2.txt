一些思考：
在h5设计稿中，主要元素就是文本和图片，然后是有外壳的盒子。
文本中有比较复杂的多行文本，主要是text-left和text-center的多行文本；text-center的一般是主动换行的
还有无外壳的盒子，横向列表的话等同于单行文本；纵向列表只是为了对齐用
flexWrap列表则等同于text-left的多行文本；还有纯粹的flex包围盒子.

文本都是从左往右扩充空间的，与人眼的阅读顺序一致
图片的话，则是固定的宽高

当我们考虑align和justify时，就需要对这几种元素进行考虑。
因为文本是主体元素，而且它们都是没有外观的，可以自由扩充，所以在能扩充的地方应该尽量扩充。
但是又要尽量保持对齐属性。

对于横向列表而言，因为是我们自己构造的，所以内容是紧凑的，我们只允许它居中或者居左；
对于单行文本而言，它的包围盒子可能并不紧贴内容。我们需要强制计算出其内容的真实宽度和横坐标，然后才能确定其对齐方式。
我们只需算个大概，如果误差有一两像素的话应该不大要紧。
在align方向，我们允许其居中/居左/居右；

对于justify轴而言，很少有justify-end的情况，这个都不重要，justify-start和justify-start对于视觉上来说只是往哪边靠，对于Constained的盒子而言，
如果它已经有flex1了，则无所谓。否则只是一个靠哪边的说法。当我们把文本往两边扩充后发现其内容超过容器宽度一半，则我们认为该文本可以设为flex1；
一般而言，不会同时有多个flex1的文本。

准确的来说，因为文本是Auto的根源，所以任何Auto且没有外壳的元素，我们都应该在justify上尽可能的拉伸它，前提是父容器是constrained的

所以对已有算法的改进机制是，这些无外壳的自动元素，我们需要尽可能扩充它们。它们是页面的主体内容且拥有最高的自由度，而图片则是自由度最低的元素。

假设justify方向没有flex1的元素了。那我们就会考虑其居左/居中/居右。我们先会找到一个大的间隙，然后这个间隙可能用flex1撑开，否则的话我们还是用居中/居左/居右来对齐。

几种Auto的本质不一样：
1. 单行文本的横向Auto是可以自由扩充的
2. 多行文本的横向Auto是不自由的，不然没法换行了（如果手动居中就可以）
3. 这种Auto会向上传染